/-
Copyright (c) 2025 Bjørn Solheim. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bjørn Solheim
-/
import Mathlib.Geometry.Convex.Cone.AppendLemmas
import Mathlib.Geometry.Convex.Cone.Pointed

/-!
# Conical combinations

This file contains various basic results about conical combinations and their closure properties.
The conical hull is defined as the set of all conical combinations from a set of generators.
Conical combinations naturally define pointed cones.

## Main results

'infPointedCone_eq_conicalHull' - The smallest pointed cone
containing the set s is equal to the conical hull generated by s.

## Notation

 - no special notation defined

## References

 - https://en.wikipedia.org/wiki/Conical_combination

-/

variable (R : Type*) [Semiring R] [PartialOrder R]
variable {E : Type*} [AddCommMonoid E] [Module R E]
variable (s : Set E) {n : ℕ}

namespace ConicalCombination
open ConvexCone Fin

/-- Predicate stating that an element can be expressed as a conical combination
using elements from the set s -/
def IsConicalComb (x : E) : Prop :=
  ∃ (n : ℕ) (c : Fin n → R) (v : Fin n → E) (_ : ∀ i, v i ∈ s)
  (_ : ∀ i, 0 ≤ c i), x = ∑ i : Fin n, c i • v i

/-- Zero can be expressed as a conical combination -/
theorem zero_conical_comb : IsConicalComb R s 0 := by
  use (0 : Nat), (fun (i : Fin 0) => 0), (fun (i : Fin 0) => 0)
  simp

/-- A scalar multiple of a generator element is a conical combination -/
theorem smul_generator_conical_comb (c₁ : R)
    (h : 0 ≤ c₁) (v₁ : E) (h_mem : v₁ ∈ s) : IsConicalComb R s (c₁ • v₁) := by
  --instantiate existential quantifier with a suitable one element sequence
  use (1 : Nat), (fun (i : Fin 1) => c₁), (fun (i : Fin 1) => v₁),
    (fun (i : Fin 1) => h_mem), (fun (i : Fin 1) => h)
  simp

variable [ZeroLEOneClass R]
/-- The individual elements of a genherator set are themselves trivial conical combinations. -/
theorem generator_conical_comb {v₁ : E} (h_mem : v₁ ∈ s) :
    IsConicalComb R s v₁ := by
  --instantiate existential quantifier with a suitable one element sequence
  use (1 : Nat), (fun (i : Fin 1) => 1), (fun (i : Fin 1) => v₁),
    (fun (i : Fin 1) => h_mem), (fun (i : Fin 1) => (zero_le_one))
  simp

variable [PosMulMono R]
omit [ZeroLEOneClass R]
/-- A scalar multiple of a conical combination is a conical combination. -/
theorem smul_conical_comb_is_conical_comb (c₁ : R) (h : 0 ≤ c₁) (v₁ : E)
    (h_conicalcomb : IsConicalComb R s v₁) : IsConicalComb R s (c₁ • v₁) := by
  obtain ⟨n, c, v, h_mem, h_nonneg, h_eq⟩ := h_conicalcomb
  --instantiate extensional quantifier with the original sequence multiplied by c₁
  use n, (fun i => c₁ * c i), v, h_mem, (fun i => mul_nonneg h (h_nonneg i))
  rw [h_eq, Finset.smul_sum]
  apply Finset.sum_congr rfl
  intro i _
  rw [smul_smul]

omit [PosMulMono R]
/-- Adding two conical combinations produces a new conical combination. -/
theorem conical_comb_add_is_conical_comb (x₁ x₂ : E)
    (h₁ : IsConicalComb R s x₁) (h₂ : IsConicalComb R s x₂) :
    IsConicalComb R s (x₁ + x₂) := by
  obtain ⟨n₁, c₁, v₁, h2₁, h3₁, h4₁⟩ := h₁
  obtain ⟨n₂, c₂, v₂, h2₂, h3₂, h4₂⟩ := h₂
  let h_mem := append_mem s v₁ v₂ h2₁ h2₂
  let h_nonneg := append_nonneg R c₁ c₂ h3₁ h3₂
  use (n₁ + n₂ : Nat), (append c₁ c₂), (append v₁ v₂),
    (fun (i : Fin (n₁ + n₂)) => h_mem i), (fun (i : Fin (n₁ + n₂)) => h_nonneg i)
  rw [h4₁, h4₂]
  have h6 := sum_append (c₁ • v₁) (c₂ • v₂)
  have h7 := smul_append_distrib R c₁ v₁ c₂ v₂
  have h8 : ∑ i : Fin (n₁ + n₂), append c₁ c₂ i • append v₁ v₂ i
      = ∑ i : Fin (n₁ + n₂), (append c₁ c₂ • append v₁ v₂) i
      := rfl
  rw [h8, h7]
  exact id (Eq.symm h6)


/-- The 'conical_hull R s' is the set of all conical combinations
of elements of s with scalars from R. It is a pointed cone. -/
def conicalHull [IsOrderedRing R] : PointedCone R E where
  carrier := {x | IsConicalComb R s x}
  zero_mem' := zero_conical_comb R s
  smul_mem' := by
    simp only [Set.mem_setOf_eq, Subtype.forall, Nonneg.mk_smul]
    intro c₁ hc₁ v₁ hv₁
    exact smul_conical_comb_is_conical_comb R s c₁ hc₁ v₁ hv₁
  add_mem' := by
    intro v₁ v₂ hv₁ hv₂
    exact conical_comb_add_is_conical_comb R s v₁ v₂ hv₁ hv₂


/-- The collection of all conical combinations over a set s (i.e., the conical hull of s)
contains the set s -/
theorem conicalHull_contains_generator_set [PosMulMono R] [IsOrderedRing R] :
    s ⊆ conicalHull R s := by
  simp only [conicalHull, Submodule.coe_set_mk,
    AddSubmonoid.coe_set_mk, AddSubsemigroup.coe_set_mk, Set.subset_setOf]
  exact fun x a ↦ generator_conical_comb R s a

end ConicalCombination

namespace PointedCone
open ConicalCombination

variable [IsOrderedRing R]
/-- 'IsPointedCone' - Prop version -/
def IsPointedCone (E : Type*) [AddCommMonoid E] [Module R E]
    (C : Set E) : Prop :=
  ∃ (T : PointedCone R E), (T.carrier = C)

/-- A term of type pointed cone is never empty since it always contains the zero element. -/
theorem nonempty {R : Type*} [Semiring R] [PartialOrder R] [IsOrderedRing R]
    {E : Type*} [AddCommMonoid E] [Module R E] (C : PointedCone R E) :
    C.carrier.Nonempty := by
  rw [Set.nonempty_iff_ne_empty, ne_eq]
  exact ne_of_mem_of_not_mem' C.zero_mem' fun a ↦ a

/-- If a set is a pointed cone, then it is nonempty -/
theorem nonempty' (C : Set E) (hC : IsPointedCone R E C) : C.Nonempty := by
  obtain ⟨T, rfl⟩ := hC
  exact PointedCone.nonempty T

/-- C is a pointed cone iff C is nonempty and contains all two element conical combinations.
This gives an equivalent more compact characterization of pointed cones
which is easier to use in some proofs -/
theorem pointedCone_iff_forall_nonneg (E : Type*) [AddCommMonoid E] [Module R E]
    (C : Set E) : IsPointedCone R E C ↔
      C.Nonempty ∧ ∀ (x : E), x ∈ C → ∀ (y : E), y ∈ C → ∀ (a b : R),
      0 ≤ a → 0 ≤ b → a • x + b • y ∈ C := by
  constructor
  · -- the first direction
    rintro ⟨T, rfl⟩
    constructor
    · exact nonempty T
    · rintro x hx y hy a b ha hb
      exact T.add_mem' (T.smul_mem' ⟨a, ha⟩ hx) (T.smul_mem' ⟨b, hb⟩ hy)
  · -- the other direction
    rintro ⟨h1, h2⟩
    use {
      carrier := C,
      zero_mem' := by
        obtain ⟨x, hx⟩ := h1
        simpa [zero_smul, add_zero] using h2 x hx x hx 0 0 (le_refl _) (le_refl _),
      add_mem' := by
        intro x y hx hy
        simpa [one_smul] using h2 x hx y hy 1 1 zero_le_one zero_le_one,
      smul_mem' := by
        intro c x hx
        have := h2 x hx x hx (c : R) 0 c.property (le_refl 0)
        simp_all
    }

/-- A pointed cone contains all conical combination of elements from any given subset. -/
theorem conical_comb_mem (c : Fin n → R) (v : Fin n → E) (h1 : ∀ i, v i ∈ s)
    (h2 : ∀ i, 0 ≤ c i) (C : PointedCone R E) (hs : s ⊆ C) :
    ∑ i : Fin n, c i • v i ∈ C
    := by
  have hpc : IsPointedCone R E C := by use C; exact rfl
  have hpc1 := pointedCone_iff_forall_nonneg R E C
  induction n with
  | zero =>
    simp
  | succ n ih =>
    simp [Fin.sum_univ_succ]
    have h0 : c 0 • v 0 ∈ C.carrier := by
      have hv0 : v 0 ∈ C := hs (h1 0)
      have hh0 := (hpc1.mp hpc).2 (v 0) (hv0) (v 0) (hv0) (c 0) 0
        (h2 0) (Preorder.le_refl 0)
      rwa [zero_smul, add_zero] at hh0
    have ihn : ∑ i : Fin n, c i.succ • v i.succ ∈ C.carrier :=
      ih (fun i ↦ c i.succ) (fun i ↦ v i.succ) (fun i ↦ h1 i.succ) fun i ↦ h2 i.succ
    have g_instance := (hpc1.mp hpc).2 (c 0 • v 0) (h0) (∑ i : Fin n, c i.succ • v i.succ) (ihn)
      1 1 (zero_le_one' R) (zero_le_one' R)
    exact (Submodule.add_mem C h0) (ih (fun i ↦ c i.succ)
      (fun i ↦ v i.succ) (fun i ↦ h1 i.succ) fun i ↦ h2 i.succ)

/-- 'inf_pointedcone_containing_set R s' is the smallest pointed cone
with elements from E and scalars from R that contains the set s. -/
def infPointedCone : PointedCone R E := sInf { C : PointedCone R E | s ⊆ C }

/-- The smallest pointed cone containing the set s
is equal to the conical hull generated by s. -/
theorem infPointedCone_eq_conicalHull : infPointedCone R s = conicalHull R s := by
  -- show inclusion in both directions
  apply le_antisymm
  -- Direction 1: `infPointedCone ≤ conical_hull`
  case a =>
    apply sInf_le
    exact conicalHull_contains_generator_set R s
  -- Direction 2: `conical_hull ≤ infPointedCone`
  case a =>
    apply le_sInf
    intro C hC y hy
    obtain ⟨n, c, v, hv_s, hc, rfl⟩ := hy
    exact conical_comb_mem R s c v hv_s hc C hC

end PointedCone
